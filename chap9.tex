
\chapter{Conclusiones}\label{cha:conclusiones}

% El objetivo general de esta tesina es implementar un servicio web que permita manipular y visualizar en tiempo real los robots Múltiplo N6 del proyecto “Programando con robots y software libre”.
%
% % Como objetivos específicos se plantean:
% Investigar propuestas similares en el marco del software libre.
% Analizar distintos mecanismos de interacción entre el servidor y los clientes como el uso de HTTP de la forma tradicional (sin estado y con conexiones volátiles), las técnicas Comet1 y el protocolo WebSockets2.
% Analizar frameworks web para Python que permitan usar protocolos como WebSockets o técnicas como Comet.
% Evaluar eficiencia y disponibilidad de implementaciones de mecanismos de serialización no estructurados como JSON3, BSON4 y CBOR5.
% Evaluar la API generada desde distintas plataformas.


El objetivo general de esta tesina de implementar un servicio Web que permita
manipular y visualizar en tiempo real los robots Multiplo N6 del proyecto
\proyecto{} se logró con una implementación usando el lenguaje Python con
las bibliotecas:

\begin{itemize}
    \item Tornado como framework Web y soporte de WebSockets del lado del
    servidor.
    \item SqlAlchemy para el acceso a la base de datos.
    \item DuinoBot para controlar los robots ``N6''.
    \item Myro para controlar los robots ``Scribbler''.
    \item Sniffer\footnote{\url{https://pypi.python.org/pypi/sniffer}} y
    Nose\footnote{\url{https://nose.readthedocs.org/en/latest/}} para correr
    los tests de forma automatizada.
    \item Diversos módulos de la biblioteca estándar.
\end{itemize}

El framework Tornado resultó ser adecuado para el uso de WebSockets y el manejo
de demoras en las respuestas gracias a que viene con soporte para WebSockets
incorporado y además cuenta con diversas utilidades para la atención de peticiones
de forma asincrónica.

En cuanto al análisis de mecanismos de comunicación no se logró llevar a cabo
en profundidad por lo que no se presenta una comparativa entre las distintas
alternativas en este documento sino que se mencionan las características propias
del mecanismo elegido que es el protocolo y API WebSockets. Este protocolo fue
elegido ya que está estandarizado y su uso se está popularizando cada vez más,
y si bien la API WebSockets está en proceso de estándarización es soportada
por los navegadores más usados en la actualidad.

De forma similar la comparación entre frameworks Web se realizó rápidamente
dado que el primer framework probado (Tornado) tenía soporte para todas
las funcionalidades requeridas o deseables para este trabajo (principalmente
soporte de WebSockets, asincronismo, renderizado de templates).
A la vez Tornado no impone
una modalidad de trabajo, como puede hacer un framework más orientado al
desarrollo de aplicaciones Web utilizando patrón Model View Controler
como por ejemplo Django que puede llegar a ser más adecuado para el desarrollo
de aplicaciones que dependan más del acceso a una base de datos que el
trabajo presente. Por esto de la misma forma que con los WebSockets se mencionan
las características del framework sin compararlo explícitamente con otros.

Para disminuir la cantidad de bytes de información enviados sin impactar el
uso de CPU tanto del servidor como de los clientes se hizo un estudio con
múltiples pruebas en Python y Javascript con los mecanismos de serialización
JSON, CBOR y BSON (el primero de texto plano y soportado de forma nativa en los
tres clientes implementados y el resto binarios). Estas pruebas se presentan
en el anexo~\ref{cha:serializacion}, las mismas apuntan a que el uso de JSON
no genera mensajes significativamente más grandes que las otras alternativas
(incluso son ligeramente más pequeños que los generados con BSON), a la vez
que el tiempo de para codificar y decodificar los mensajes con JSON en
Javascript es menor que las otras anternativas y en Python no presenta
diferencias significativas para mensajes relativamente pequeños como los utilizado
por XRemoteBot.

La API generada fue probada con 3 clientes distintos incorporados en este
trabajo, de los cuales el cliente Javascript se puede ejecutar desde el
navegador (inclusive desde dispositivos móviles) y los clientes Python y
Ruby se pueden usar en cualquier computadora
donde se puedan instalar sus intérpretes (abarcando computadoras con
los sistemas operativos GNU/Linux, *BSD, Windows y Mac).

Los clientes Ruby y Python son los más simples y pueden requerir algo
más de desarrollo para pulir detalles. En ambos casos los errores
retornados por el servidor se convierten en excepciones de la clase
\texttt{Exception}, incluyendo en el protocolo un código de error
se podría implementar un control de errores más específico en
los clientes lanzando distintas excepciones para distintos tipos
de errores. En el caso del cliente Javascript esto se resolvió
naturalmente usando \textit{Promises} en lugar de excepciones.

El sistema resultante es fácilmente extensible en tres aspectos:
\begin{itemize}
    \item Dada su sencilles protocolo es fácilmente extensible.
    \item Definiendo un script en ``remotebot/robots/<nombre>.py''
en el servidor y agregand ``<nombre>'' en la opción ``robots''
de la configuración es suficiente para agregar soporte
para un nuevo robot.
    \item Si se requiere controlar un dispositivo tan distinto de los
        robots que requeriría métodos muy distintos se pueden definir
        nuevas entidades, una entidad simplemente es una clase que
        hereda de ``remotebot.models.entity.Entity'' y que se
        registra al final del archivo ``remotebot/handlers/ws\_handler.py''
        con el método \texttt{WSHandler.register\_api\_handler()}.
        En el método anterior recibe como primer argumento el
        nombre de la entidad y como segundo argumento una instancia
        de una clase que herede de ``remotebot.models.entity.Entity''.
\end{itemize}
