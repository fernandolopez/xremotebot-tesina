\chapter{Pruebas}\label{cha:pruebas}

El servidor se probó con Python 2.7 (portarlo a Python 3 involucraría
portar DuinoBot, Myro y otros módulos asociados) en entornos creados
con virtualenv\footnote{FIXME REF} y con una base de datos
Sqlite\footnote{FIXME REF}
sobre
sistemas Lihuen 5 y 6 beta (basados en Debian Wheezy y Jessie respectivamente).
Las dependencias se instalaron declarandolas en \texttt{setup.py} e instalandolas
con pip, a excepción de los módulos DuinoBot y Myro que fueron instalados
desde repositorios Git usando también pip, pero indicando la URL manualmente
ya que no fué posible declararlos de esta manera en \texttt{setup.py}.

\begin{lstlisting}[language=bash,caption={Instalación de XRemoteBot},label=]
git clone https://github.com/fernandolopez/xremotebot.git
cd xremotebot
virtualenv .
. bin/activate
pip install -r requirements.txt
pip install 'git+https://github.com/Robots-Linti/duinobot.git@pygame_opcional'
pip install 'git+https://github.com/fernandolopez/Myro.git'
\end{lstlisting}

Para soportar el streaming de video además es necesario 



\begin{lstlisting}[language=bash,caption={Instalación de XRemoteBot},label=]
./run.sh
\end{lstlisting}

usando los archivos requirementes.txt
y requirements-dev.txt, a excepción de los módulos DuinoBot y Myro que se
instalaron con pip desde Git por lo que no fue posible usar los archivos



\chapter{Conclusiones}\label{cha:conclusiones}

% El objetivo general de esta tesina es implementar un servicio web que permita manipular y visualizar en tiempo real los robots Múltiplo N6 del proyecto “Programando con robots y software libre”.
%
% % Como objetivos específicos se plantean:
% Investigar propuestas similares en el marco del software libre.
% Analizar distintos mecanismos de interacción entre el servidor y los clientes como el uso de HTTP de la forma tradicional (sin estado y con conexiones volátiles), las técnicas Comet1 y el protocolo WebSockets2.
% Analizar frameworks web para Python que permitan usar protocolos como WebSockets o técnicas como Comet.
% Evaluar eficiencia y disponibilidad de implementaciones de mecanismos de serialización no estructurados como JSON3, BSON4 y CBOR5.
% Evaluar la API generada desde distintas plataformas.


El objetivo general de esta tesina de implementar un servicio Web que permita
manipular y visualizar en tiempo real los robots Multiplo N6 del proyecto
\proyecto{} se logró con una implementación usando el lenguaje Python con
las bibliotecas:

\begin{itemize}
    \item Tornado como framework Web y soporte de WebSockets del lado del
    servidor.
    \item SqlAlchemy para el acceso a la base de datos.
    \item DuinoBot para controlar los robots ``N6''.
    \item Myro para controlar los robots ``Scribbler''.
    \item Sniffer\footnote{\url{https://pypi.python.org/pypi/sniffer}} y
    Nose\footnote{\url{https://nose.readthedocs.org/en/latest/}} para correr
    los tests de forma automatizada.
    \item Diversos módulos de la biblioteca estándar.
\end{itemize}

El framework Tornado resultó ser adecuado para el uso de WebSockets y el manejo
de demoras en las respuestas gracias a que viene con soporte para WebSockets
incorporado y además cuenta con diversas utilidades para la atención de peticiones
de forma asincrónica.

En cuanto al análisis de mecanismos de comunicación no se logró llevar a cabo
en profundidad por lo que no se presenta una comparativa entre las distintas
alternativas en este documento sino que se mencionan las características propias
del mecanismo elegido que es el protocolo y API WebSockets. Este protocolo fue
elegido ya que está estandarizado y su uso se está popularizando cada vez más,
y si bien la API WebSockets está en proceso de estándarización es soportada
por los navegadores más usados en la actualidad.

De forma similar la comparación entre frameworks Web se realizó rápidamente
dado que el primer framework probado (Tornado) tenía soporte para todas
las funcionalidades requeridas o deseables para este trabajo (principalmente
soporte de WebSockets, asincronismo, renderizado de templates) sin imponer
una modalidad de trabajo como puede hacer un framework más orientado al
desarrollo de aplicaciones Web utilizando patrón Model View Controler
como por ejemplo Django que puede llegar a ser más adecuado para el desarrollo
de aplicaciones que dependan más del acceso a una base de datos que el
trabajo presente. Por esto de la misma forma que con los WebSockets se mencionan
las características del framework sin compararlo explícitamente con otros.

Para disminuir la cantidad de bytes de información enviados sin impactar el
uso de CPU tanto del servidor como de los clientes se hizo un estudio con
múltiples pruebas en Python y Javascript con los mecanismos de serialización
JSON, CBOR y BSON (el primero de texto plano y soportado de forma nativa en los
tres clientes implementados y el resto binarios). Estas pruebas se presentan
en el anexo~\ref{cha:serializacion}, las mismas apuntan a que el uso de JSON
no genera mensajes significativamente más grandes que las otras alternativas
(incluso son ligeramente más pequeños que los generados con BSON), a la vez
que el tiempo de para codificar y decodificar los mensajes con JSON en
Javascript es menor que las otras anternativas y en Python no presenta
diferencias significativas para mensajes relativamente pequeños como los utilizado
por XRemoteBot.

La API generada fue probada con 3 clientes distintos incorporados en este
trabajo, de los cuales el cliente Javascript se puede ejecutar desde el
navegador (inclusive desde dispositivos móviles y los clientes Python y
Ruby se pueden usar en cualquier computadora
donde se puedan instalar sus intérpretes (abarcando computadoras con
los sistemas operativos GNU/Linux, *BSD, Windows y Mac).

